import jp.progression.errors.ArgumentError;import jp.progression.scenes.proto.SceneObject;import jp.progression.utils.MathUtil;/** *  * Progression Framework for ActionScript 2.0 *  * @author	Copyright (c) 2007 Mk-10:cellfusion.jp, supported by Spark project. * @version	2.0.0 Alpha 1 *  * @see		http://progression.jp/ * @see		http://usage.progression.jp/ * @see		http://progression.libspark.org/ *  * @see		http://cellfusion.jp/ * @see		http://www.libspark.org/ *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or implied. See the License for the specific language * governing permissions and limitations under the License. *  */class jp.progression.core.collections.SceneList {	private var _dictionary:Object;		private function getNumScenes():Number { return getScenes().length; }		private function getScenes():Array { return _scenes; }	private var _scenes:Array;		private var _parent:SceneObject;		private var _indexToScenes:Object;		private var _nameToScenes:Object;		private var _sceneToIndexs:Object;			public function SceneList(parent:SceneObject)	{		_parent = parent;				_scenes = new Array();		_indexToScenes = new Object();		_nameToScenes = new Object();		_sceneToIndexs = new Object();	}		private function sort():Void	{		// すべてのインデックス値を取得する		var list:Array = new Array();		var l:Number = _scenes.length;		for (var i:Number = 0; i < l; i++) {			list.push({				child:_scenes[i],				index:_sceneToIndexs[_scenes[i]]			});		}				// インデックス値でソートする		list.sortOn("index", Array.NUMERIC);				// 配列を初期化する		_scenes = new Array();				// ソート済みの配列をコピーする		l = list.length;		for (i = 0; i < l; i++) {			_scenes.push(list[i].child);		}	}		private function addScene(scene:SceneObject):SceneObject	{		// 自分自身を追加しようとしたらエラーを送出する		if (scene == _parent) {			throw new ArgumentError("Error: オブジェクトをそれ自体の子として追加することはできません。");		}				// 対象が自信の親であればエラーを送出する		var target:SceneObject = _parent;		while(target != target.parent) {			if (target == scene) {				throw new ArgumentError("Error: オブジェクトをそれ自体の子(またはその子の子など)として追加することはできません。");			}						// 親に遡る			target = target.parent;		}				// すでに登録されていれば削除する		if (scene.parent && scene.parent.contains(scene)) {			scene.parent.removeScene(scene);		}				// すでに同じシーン名の SceneObject が存在すれば削除する		if (_nameToScenes[scene.name]) {			_parent.removeScene(_nameToScenes[scene.name]);		}				// 最高値のインデックス位置を取得する		var index:Number = _scenes.length ? _sceneToIndexs[_scenes[_scenes.length-1]] + 1 : 0;				// 登録する		_indexToScenes[index] = scene;		_nameToScenes[scene.name] = scene;		_sceneToIndexs[scene] = index;		_scenes.push(scene);		//		trace("_nameToScenes : "+_nameToScenes[scene.name]);				return scene;	}		private function addSceneAt(scene:SceneObject, index:Number, addAbove:Boolean):SceneObject	{		if (addAbove != undefined) addAbove = false;				// 自分自身を追加しようとしたらエラーを送出する		if (scene = _parent) {			throw new ArgumentError("Error: オブジェクトをそれ自体の子として追加することはできません。");		}				// 対象が自信の親であればエラーを送出する		var target:SceneObject = _parent;		while(target != target.parent) {			if (target == scene) {				throw new ArgumentError("Error: オブジェクトをそれ自体の子(またはその子の子など)として追加することはできません。");			}						// 親に遡る			target = target.parent;		}				// すでに登録されていれば削除する		if (scene.parent && scene.parent.contains(scene)) {			scene.parent.removeScene(scene);		}				// すでに同じシーン名の SceneObject が存在すれば削除する		if (_nameToScenes[scene.name]) {			_parent.removeScene(_nameToScenes[scene.name]);		}				// 0 以上に数値を丸める		index = Math.max(0, index);				// 指定インデックス位置にすでに登録済みであれば以降のインデックスを上にずらす		if (_indexToScenes[index] instanceof SceneObject) {			// 仮想インデックス値を取得する			var virtualIndex:Number = _sceneToIndexs[_indexToScenes[index]];						// 対象の上に配置する			if (addAbove) {				virtualIndex++;				index++;			}						// インデックス位置を操作する			var l:Number = _scenes.length;			for (var i:Number = virtualIndex; i < l; i++) {				var chd1:SceneObject = _indexToScenes[Math.max(virtualIndex, i-1)];				var chd2:SceneObject = _indexToScenes[i];								// 一つ前のインデックス位置と重複していなければ終了する				if (_sceneToIndexs[chd1] != _sceneToIndexs[chd2]) break;								// 値を一つずらす				var idx:Number = _sceneToIndexs[chd2] + 1;				_sceneToIndexs[chd2] = idx;				_indexToScenes[idx] = chd2;			}		}				// データを格納する		_indexToScenes[index] = scene;		_nameToScenes[scene.name] = scene;		_sceneToIndexs[scene] = index;		_scenes.push(scene);				// インデックス値でソートする		sort();				return scene;	}		private function removeScene(scene:SceneObject):SceneObject	{		// 子に登録されていない SceneObject インスタンスであればエラーを送出する		if (!(_sceneToIndexs[scene] instanceof Number)) {			throw new ArgumentError("Error: 指定した DisplayObject は呼び出し元の子でなければなりません。");		}				// 削除する		delete _indexToScenes[_sceneToIndexs[scene]];		delete _nameToScenes[scene.name];		delete _sceneToIndexs[scene];				var l:Number = _scenes.length;		for (var i:Number = 0; i < l; i++) {			if (_scenes[i] != scene) continue;						// 削除する			_scenes.splice(i, 1);			break;		}				return scene;	}		private function removeSceneAt(index:Number):SceneObject	{		return removeScene(_indexToScenes[index]);	}		private function contains(scene:SceneObject):Boolean	{		// 存在すれば true を返す		if (_sceneToIndexs[scene]) return true;				// 子に存在すれば true を返す		for (var idx:String in _indexToScenes) {			var scene:SceneObject = _indexToScenes[idx];			if (scene.contains(scene)) return true;		}				return false;	}	private function getSceneAt(index:Number):SceneObject	{		return _indexToScenes[index];	}		private function getSceneByName(name:String):SceneObject	{//		trace("getScene\n\tname:"+name+"\n\treturn:"+_scenes[name]);		return _nameToScenes[name];	}		private function getNextScene(scene:SceneObject):SceneObject	{		var l:Number = _scenes.length;		for (var i:Number = 0; i < l; i++) {			if (_scenes[i] == scene) return _scenes[MathUtil.cycle(i+1, l)];		}				return null;	}		private function getPreviousScene(scene:SceneObject):SceneObject	{		var l:Number = _scenes.length;		for (var i:Number = 0; i < l; i++) {			if (_scenes[i] == scene) return _scenes[MathUtil.cycle(i-1, l)];		}				return null;	}		private function getSceneIndex(scene:SceneObject):SceneObject	{		return _sceneToIndexs[scene];	}		private function setSceneIndex(scene:SceneObject, index:Number, addAbove:Boolean):Void	{		if (addAbove != undefined) addAbove = false;		addSceneAt(removeScene(scene), index, addAbove);	}		private function swapScenes(scene1:SceneObject, scene2:SceneObject):Void	{		// インデックス位置を格納する		var index1:Number = _sceneToIndexs[scene1];		var index2:Number = _sceneToIndexs[scene2];				// シーンリストから削除する		removeScene(scene1);		removeScene(scene2);				// シーンリストに追加する		addSceneAt(scene1, index2);		addSceneAt(scene2, index1);	}		private function swapScenesAt(index1:Number, index2:Number):Void	{		// ディスプレイオブジェクトを格納する		var scene1:SceneObject = _indexToScenes[index1];		var scene2:SceneObject = _indexToScenes[index2];				// シーンリストから削除する		removeScene(scene1);		removeScene(scene2);				// シーンリストに追加する		addSceneAt(scene1, index2);		addSceneAt(scene2, index1);	}		private function getChild(name:Object):Object	{//		trace("getChild name:"+name);//		//		trace("_nameToScenes:"+_nameToScenes);//		//		trace("_nameToScenes dump");//		for (var idx:String in _nameToScenes) {//			trace(idx+":"+_nameToScenes[idx]);//		}//				return _nameToScenes[name];	}}