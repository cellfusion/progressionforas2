import jp.progression.core.commands.Command;import jp.progression.core.commands.CommandList;import jp.progression.events.CommandCatchEvent;import jp.progression.events.CommandEvent;import mx.utils.Delegate;/** *  * Progression for ActionScript 2.0 *  * @author	Copyright (c) 2007 Mk-10:cellfusion.jp, supported by Spark project. * @version	1.0.0 Alpha *  * @see		http://progression.jp/ * @see		http://usage.progression.jp/ * @see		http://progression.libspark.org/ *  * @see		http://cellfusion.jp/ * @see		http://www.libspark.org/ *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or implied. See the License for the specific language * governing permissions and limitations under the License. *  */class jp.progression.commands.SerialList extends CommandList{	private var _currentCount:Number = 0;	private var _currentCommand:Command;		private var _commandStartDelegate:Function;	private var _commandProgressDelegate:Function;	private var _commandCompleteDelegate:Function;	private var _catchDelegate:Function;		public function SerialList(delay:Number, commands:Array)	{		super("SerialList", delay ? 0 : delay, commands);				_commandStartDelegate = Delegate.create(this, _commandStartHandler);		_commandProgressDelegate = Delegate.create(this, _commandProgressHandler);		_commandCompleteDelegate = Delegate.create(this, _commandCompleteHandler);		_catchDelegate = Delegate.create(this, _catchHandler);	}		private function _executeProgress():Void	{		if (commands.length == 0)		{			_executeComplete();			return;		}				// 処理ラインを初期化する		_currentCount = 0;				// 処理を実行する		_execute();	}		private function _execute():Void	{		if (_currentCount >= commands.length)		{			// 処理を終了する			_executeFinally(new CommandEvent(CommandEvent.COMMAND_COMPLETE));			return;		}				_currentCommand = Command(commands[_currentCount++]);		_currentCommand.addEventListener(CommandEvent.COMMAND_START, _commandStartDelegate);		_currentCommand.addEventListener(CommandEvent.COMMAND_PROGRESS, _commandProgressDelegate);		_currentCommand.addEventListener(CommandEvent.COMMAND_COMPLETE, _commandCompleteDelegate);		_currentCommand.addEventListener(CommandCatchEvent.EXCEPTION, _catchDelegate);		_currentCommand.addEventListener(CommandCatchEvent.EVENT, _catchDelegate);		_currentCommand.execute(extra);	}		public function interrupt():Void	{		if (!running) return;				if (_currentCommand)		{			_currentCommand.removeAllListeners();			_currentCommand.interrupt();		}				dispatchEvent(new CommandEvent(CommandEvent.COMMAND_INTERRUPT));	}		public function clone():Command	{		var com:CommandList = new SerialList(delay);		com.enabled = enabled;		com.before(_beforeScope, _beforeFunc, _beforeArgs);		com.after(_afterScope, _afterFunc, _afterArgs);				var l:Number = commands.length;		for (var i:Number = 0; i < l; i++) com.addCommand(commands[i]);				return Command(com);	}				private function _commandStartHandler(e:CommandEvent):Void	{		Command(e.target).removeEventListener(CommandEvent.COMMAND_START, _commandStartDelegate);				dispatchEvent(new CommandEvent(CommandEvent.COMMAND_PROGRESS));	}		private function _commandProgressHandler(e:CommandEvent):Void	{		dispatchEvent(new CommandEvent(CommandEvent.COMMAND_PROGRESS));	}		private function _commandCompleteHandler(e:CommandEvent):Void	{		Command(e.target).removeAllListeners();				_currentCommand = null;				_execute();	}		private function _catchHandler(e:CommandCatchEvent):Void	{		Command(e.target).removeAllListeners();				_currentCommand = null;				_executeCatch(e);	}}