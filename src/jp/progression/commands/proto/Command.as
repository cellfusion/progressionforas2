import mx.events.EventDispatcher;import mx.utils.Delegate;import jp.progression.Progression;import jp.progression.events.CommandCatchEvent;import jp.progression.events.CommandEvent;import jp.progression.events.Event;import jp.progression.events.EventIntegrator;import jp.progression.events.TimerEvent;import jp.progression.utils.ObjectUtil;import jp.progression.utils.Timer;import jp.progression.utils.StringUtil;/** *  * Progression for ActionScript 2.0 *  * @author	Copyright (c) 2007 Mk-10:cellfusion.jp, supported by Spark project. * @version	1.0.0 Alpha *  * @see		http://progression.jp/ * @see		http://usage.progression.jp/ * @see		http://progression.libspark.org/ *  * @see		http://cellfusion.jp/ * @see		http://www.libspark.org/ *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or implied. See the License for the specific language * governing permissions and limitations under the License. *  */class jp.progression.commands.proto.Command extends EventIntegrator{	static public function get intermission():Number { return _intermission; }	static public function set intermission(value:Number):Void { _intermission = Math.max(0, value); }	static private var _intermission:Number = 0;		static public function get thresholdDepth():Number { return _thresholdDepth; }	static public function set thresholdDepth(value:Number):Void { _thresholdDepth = Math.max(0, value); }	static private var _thresholdDepth:Number = 5;		public function get name():String { return _name; }	public function get _name():String { return __name; }	public function set _name(value:String):Void { __name = value; }	private var __name:String;		public function get type():String { return _type; }	private var _type:String;		public function get enabled():Boolean { return _enabled; }	public function set enabled(value:Boolean):Void { _enabled = value; }	private var _enabled:Boolean;		public function running():Boolean { return _running; }	private var _running:Boolean;		public function interrupting():Boolean { return _interrupting; }	private var _interrupting:Boolean;		public function get delay():Number { return _delay; }	public function set delay(value:Number):Void { _delay = Math.max(0, value); }	private var _delay:Number = 0;		public function get extra():Object { return _extra; }	private var _extra:Object;		public function get _beforeFunc():Function { return __beforeFunc; }	private var __beforeFunc:Function;		public function get _beforeArgs():Array { return __beforeArgs; }	private var __beforeArgs:Array;		public function get _beforeScope():Object { return __beforeScope; }	private var __beforeScope:Object;		public function get _afterFunc():Function { return __afterFunc; }	private var __afterFunc:Function;		public function get _afterArgs():Array { return __afterArgs; }	private var __afterArgs:Array;		public function get _afterScope():Object { return __afterScope; }	private var __afterScope:Object;		private function getParent():Command { return _parent; }	private function setParent(value:Command):Void { _parent = value; }	private var _parent:Command;		private function getDepth():Number { return _depth; }	private function setDepth(value:Number):Void { _depth = value }	private var _depth:Number;		private var _timer:Timer;		private var _timerCompleteDelegate:Function;	
	public function Command(type:String, delay:Number)	{		if (delay == undefined) delay = 0;				// 引数を設定		_type = type;		this.delay = delay;				// 初期化する		_enabled = true;		_running = false;		_interrupting =false;				_extra = new Object();		_timer = new Timer(1, 1);		__beforeArgs = new Array();		__afterArgs = new Array();				_timerCompleteDelegate = Delegate.create(this, _timerCompleteHandler);	}		/**	 * コマンドを実行	 */	public function execute(extra:Object):Void	{		if (extra == undefined) extra = null;		_extra = extra ? extra : new Object();				// 遅延時間を取得		var delayTime:Number = intermission + delay;				// 限界深度を超えていれば遅延を発生させる		if (_depth > _thresholdDepth) delayTime = Math.max(1, delayTime+1);				// 遅延時間の設定がなければ処理を実行		if (delayTime == 0)		{			_executeStart();			return;		}				// Timer を開始する		_timer.reset();		_timer.delay = delayTime;		_timer.addEventListener(TimerEvent.TIMER_COMPLETE, _timerCompleteDelegate);		_timer.start();	}		/**	 * 	 */	private function _executeStart():Void	{		Progression.log(StringUtil.repeat("  ", _depth+1)+" <"+type+"> コマンドを実行します。");				//処理を開始		_running = true;				// イベントを発行		dispatchEvent(new CommandEvent(CommandEvent.COMMAND_START));				// 事前処理を実行する		if (_beforeFunc instanceof Function) {			try {				_beforeFunc.apply(_beforeScope, _beforeArgs);			} catch(e:Error) {				dispatchEvent(new CommandCatchEvent(CommandCatchEvent.EXCEPTION, this, e));				return;			}		}				// 実行可能であれば		if (enabled) {			try {				_executeProgress();			} catch(e:Error) {				dispatchEvent(new CommandCatchEvent(CommandCatchEvent.EXCEPTION, this, e));				return;			}			return;		}				// 処理終了する		_executeComplete();	}		/**	 * 	 */	private function _executeProgress():Void	{		_executeComplete();	}		/**	 * 	 */	private function _executeComplete():Void	{		// 事後処理を実行する		if (_afterFunc instanceof Function) {			try {				_afterFunc.apply(_afterScope, _afterArgs);			} catch(e:Error) {				dispatchEvent(new CommandCatchEvent(CommandCatchEvent.EXCEPTION, this, e));				return;			}		}				// 処理を終了する		_running = false;				// イベントを発行		dispatchEvent(new CommandEvent(CommandEvent.COMMAND_COMPLETE));	}		/**	 * コマンド処理を停止	 */	public function interrupt():Void	{		_interruptStart();	}		private function _interruptStart():Void	{		Progression.log(StringUtil.repeat("  ", _depth+1)+" <"+type+"> コマンドを実行します。");				// 停止処理を開始する		_interrupting = true;				// 遅延中であれば		if (_timer.running) {			// リスナーを解除する			_timer.removeEventListener(TimerEvent.TIMER_COMPLETE, _timerCompleteDelegate);						// タイマーを停止する			_timer.stop();						// 停止処理を終了する			_executeComplete();			return;		}				// 実行可能であれば		if (enabled) {			try {				_interruptProgress();			} catch(e:Error) {				dispatchEvent(new CommandCatchEvent(CommandCatchEvent.EXCEPTION, this, e));				return;			}			return;		}				_interruptComplete();	}		private function _interruptProgress():Void	{		_interruptComplete();	}		private function _interruptComplete():Void	{		_interrupting = false;		_running = false;				dispatchEvent(new CommandEvent(CommandEvent.COMMAND_INTERRUPT));	}	/**	 * コマンドの実行直前に処理させたい関数を設定します。	 */	public function before(scope:Object, func:Function, args:Array):Command	{		__beforeFunc = func;		__beforeArgs = (args != undefined) ? args.concat([]) : new Array();		__beforeScope = (scope != undefined) ? scope : this;		return this;	}		/**	 * コマンドの実行完了直後に処理させたい関数を設定します。	 */	public function after(scope:Object, func:Function, args:Array):Command	{		__afterFunc = func;		__afterArgs = args != undefined ? args.concat([]) : new Array();		__afterScope = scope != undefined ? scope : this;		return this;	}		/**	 * コマンドに対してすぐに関数を実行します。	 */	public function apply(func:Function, args:Array):Command	{		func.apply(this, args);		return this;	}		/**	 * 	 */	public function setProperties(props:Object):Command	{		ObjectUtil.setProperties(this, props);		return this;	}		/**	 * Command オブジェクトのクローンを作成	 */	public function clone():Command	{		var com:Command = new Command(type, delay);		com.enabled = enabled;		com.before(_beforeScope, _beforeFunc, _beforeArgs);		com.after(_afterScope, _afterFunc, _afterArgs);		return com;	}		public function toString():String	{		return "[object Command]";	}			// ココからイベントハンドラメソッド		private function _timerCompleteHandler(e:TimerEvent):Void	{		Timer(e.target).removeEventListener(TimerEvent.TIMER_COMPLETE, _timerCompleteDelegate);				// 処理を開始する		_executeStart();	}}