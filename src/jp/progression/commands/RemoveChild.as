import jp.progression.commands.proto.Command;import jp.progression.events.CommandCatchEvent;import jp.progression.events.CommandEvent;import spark.display.DisplayObject;import spark.display.DisplayObjectContainer;import mx.utils.Delegate;/** *  * Progression for ActionScript 2.0 *  * @author	Copyright (c) 2007 Mk-10:cellfusion.jp, supported by Spark project. * @version	1.0.0 Alpha *  * @see		http://progression.jp/ * @see		http://usage.progression.jp/ * @see		http://progression.libspark.org/ *  * @see		http://cellfusion.jp/ * @see		http://www.libspark.org/ *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or implied. See the License for the specific language * governing permissions and limitations under the License. *  */class jp.progression.commands.RemoveChild extends Command {//	public function get enabled():Boolean//	{//		return (container instanceof ExMovieClip && cast instanceof ICastObject) ? super.enabled : false;//	}	public function get container():DisplayObjectContainer { return _container; }	public function set container(value:DisplayObjectContainer):Void { _container = value; }	private var _container:DisplayObjectContainer;	public function get child():DisplayObject { return _child; }	public function set child(value:DisplayObject):Void { _child = value; }	private var _child:DisplayObject;		public function get autoAlpha():Boolean { return _autoAlpha; }	public function set autoAlpha(value:Boolean):Void { _autoAlpha = value; }	private var _autoAlpha:Boolean;		private var _command:Command;	private var _commandInterruptDelegate:Function;	private var _commandCompleteDelegate:Function;	private var _catchDelegate:Function;		public function RemoveChild(container:DisplayObjectContainer, child:DisplayObject, delay:Number) 	{		super("RemoveChild", delay);				this.container = (container != undefined) ? container : null;//		this.cast = (cast != undefined) ? cast : null;		this.child = (child != undefined) ? child : null;		this.autoAlpha = (autoAlpha != undefined) ? autoAlpha : false;				_commandInterruptDelegate = Delegate.create(this, _commandInterrupt);		_commandCompleteDelegate = Delegate.create(this, _commandComplete);		_catchDelegate = Delegate.create(this, _catch);	}		private function _executeProgress():Void	{		// すでに配置されていなければ終了する		if (!container.contains(child)) {			_executeComplete();			return;		}				// キャストのコマンドリストを消去する//		cast.clearCommand();				// イベントを送出する//		cast.dispatchEvent(new CastEvent(CastEvent.CAST_REMOVED));				// コマンドを取得する//		var com:CommandList = CommandList(cast["getCommands"]());				// autoAlphaプロパティが有効であれば//		if (autoAlpha) {////			cast.alpha = 0;//			com = (com) ? com : new SerialList();//			//			var coms:Array = com.commands;//			coms.unshift(new DoTween(cast, {alpha:0}, Regular.easeInOut, 500, 10));//			//			com = new SerialList();//			//			var l:Number = coms.length;//			for (var i:Number = 0; i < l; i++) {//				com.addCommand(coms[i]);//			}//		} 				// コマンドが存在すれば実行する//		if (com && com.length > 0) {//			_command = CommandList(com.clone());//			_command.addExclusivelyEventListener(CommandEvent.COMMAND_COMPLETE, _commandCompleteDelegate);//			_command.addExclusivelyEventListener(CommandCatchEvent.EXCEPTION, _catchDelegate);//			_command.addExclusivelyEventListener(CommandCatchEvent.ERROR, _catchDelegate);//			_command.execute(new Object());//			return;//		}				// 画面に配置されていれば削除する//		container.destroyChild(MovieClip(cast));		container.removeChild(child);				// 処理を終了する		_executeComplete();	}		private function _interruptProgress():Void	{		// 実行中のコマンドがあれば//		if (_command) {//			// リスナーを解除する//			_command.removeAllListeners(true);//			//			// 停止する //			_command.addEventListener(CommandEvent.COMMAND_INTERRUPT, _commandInterruptDelegate);//			_command.interrupt();//			return;//		}				// 画面に配置されていれば削除する//		container.destroyChild(MovieClip(cast));		container.removeChild(child);				// 停止処理を終了する		_interruptComplete();	}		public function clone():Command	{		var com:Command = new RemoveChild(container, child, delay);		com.enabled = enabled;		com.before(_beforeScope, _beforeFunc, _beforeArgs);		com.after(_afterScope, _afterFunc, _afterArgs);		return com;	}		public function toString():String	{		return "[object RemoveChild]";	}		private function _commandComplete(e:CommandEvent):Void	{		Command(e.target).removeAllListeners(true);				_executeComplete();	}		private function _commandInterrupt(e:CommandEvent):Void	{		Command(e.target).removeAllListeners(true);				try {//			container.destroyChild(MovieClip(cast));			container.removeChild(child);		} catch(e:Error) {			dispatchEvent(new CommandCatchEvent(CommandCatchEvent.EXCEPTION, this, e));		}				_interruptComplete();	}		private function _catch(e:CommandCatchEvent):Void	{		Command(e.target).removeAllListeners();				_executeComplete();	}}