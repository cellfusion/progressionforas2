import jp.progression.core.commands.Command;import jp.progression.core.commands.CommandList;import jp.progression.events.CommandCatchEvent;import jp.progression.events.CommandEvent;import jp.progression.events.Event;import jp.progression.events.EventIntegrator;import jp.progression.events.ProcessEvent;import jp.progression.events.SceneEvent;import jp.progression.scenes.SceneId;import jp.progression.scenes.SceneObject;import mx.utils.Delegate;/** *  * Progression for ActionScript 2.0 *  * @author	Copyright (c) 2007 Mk-10:cellfusion.jp, supported by Spark project. * @version	1.0.0 Alpha *  * @see		http://progression.jp/ * @see		http://usage.progression.jp/ * @see		http://progression.libspark.org/ *  * @see		http://cellfusion.jp/ * @see		http://www.libspark.org/ *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or implied. See the License for the specific language * governing permissions and limitations under the License. *  */class jp.progression.managers.SceneManager extends EventIntegrator{	static private var _internallyCalled:Boolean = false;		/**	 * ルートのシーンを取得する	 */	public function get root():SceneObject { return _rootScene; }	private var _rootScene:SceneObject;		/**	 * 現在のシーンを取得する	 */	public function get current():SceneObject { return _current; }	private var _current:SceneObject;		public function get currentSceneId():SceneId { return _currentSceneId.clone(); }	private var _currentSceneId:SceneId;		public function get departedSceneId():SceneId { return _departedSceneId.clone(); }	private var _departedSceneId:SceneId;		public function get destinedSceneId():SceneId { return _destinedSceneId.clone(); }	private var _destinedSceneId:SceneId;		private var _previousSceneId:SceneId;		public function get eventType():String { return _eventType; }	private var _eventType:String;	public function get lock():Boolean { return _lock; }	public function set lock(value:Boolean):Void { _lock = value; }	private var _lock:Boolean;		public function get autoLock():Boolean { return _autoLock; }	public function set autoLock(value:Boolean):Void { _autoLock = value; }	private var _autoLock:Boolean;		public function get running():Boolean { return _running; }	private var _running:Boolean;		public function get interrupting():Boolean { return _interrupting; }	private var _interrupting:Boolean;		private var _command:CommandList;		private var _commandStartDelegate:Function;	private var _commandCompleteDelegate:Function;	private var _commandInterruptDelegate:Function;	private var _catchDelegate:Function;	private var _processInterruptDelegate:Function;		/**	 * 	 */	public function SceneManager(rootScene:SceneObject)	{		// パッケージ外から呼び出されたらエラーを送出する//		if (!_internallyCalled) {//			throw new ArgumentError("Error: SceneManager クラスを直接インスタンス化することはできません。");//		}				// 初期化		_lock = false;		_autoLock = false;		_running = false;		_interrupting = false;		_eventType = SceneEvent.UNLOAD;				_rootScene = rootScene;				_current = rootScene;		_currentSceneId = rootScene.sceneId.clone();		_departedSceneId = currentSceneId.clone();		_destinedSceneId = currentSceneId.clone();		_previousSceneId = currentSceneId.clone();		//		_internallyCalled = false;				_commandStartDelegate = Delegate.create(this, _commandStartHandler);		_commandCompleteDelegate = Delegate.create(this, _commandCompleteHandler);		_commandInterruptDelegate = Delegate.create(this, _commandInterruptHandler);		_processInterruptDelegate = Delegate.create(this, _processInterruptHandler);	}		/**	 * シーンを変える	 */	public function goto(sceneId:SceneId):Void	{		// すでに目的のシーンを表示していれば終了する		if (String(_currentSceneId) == String(sceneId) && eventType == SceneEvent.INIT) return;				// ロックされていたら終了する		if (lock) return;				// 目的地を設定する		_departedSceneId = _currentSceneId.clone();		_destinedSceneId = sceneId.clone();				// すでに中断処理中であれば終了する		if (interrupting) return;				// すでに処理を開始していれば停止させる		if (running) {			// リスナーを登録する			addExclusivelyEventListener(ProcessEvent.PROCESS_INTERRUPT, _processInterruptDelegate);						// 停止処理をする			interrupt();			return;		}				// オートロックが有効であればロックする		if (autoLock) lock = true;				_running = true;				// イベントを送出する		dispatchEvent(new ProcessEvent(ProcessEvent.PROCESS_START, current, eventType));				_executeStart();	}		private function _executeStart():Void	{		// 現在のシーン識別子を保存する		_previousSceneId = currentSceneId;				// 目的のシーンと同じ場合		if (String(_currentSceneId) == String(_destinedSceneId))		{			switch (_eventType)			{				case SceneEvent.LOAD : _eventType = SceneEvent.INIT; break;				case SceneEvent.DESCEND : _eventType = SceneEvent.INIT; break;				case SceneEvent.INIT : break;				case SceneEvent.GOTO : _eventType = SceneEvent.INIT; break;				case SceneEvent.ASCEND : _eventType = SceneEvent.INIT; break;				case SceneEvent.UNLOAD : _eventType = SceneEvent.LOAD; break;			}						_executeProgress();			return;		}				// 目的のシーンが子の場合		if (_currentSceneId.contains(_destinedSceneId))		{			switch (_eventType)			{				case SceneEvent.LOAD : _eventType = SceneEvent.DESCEND; break;				case SceneEvent.DESCEND :					_current = _current.scenes["getChild"](_destinedSceneId.getNameByIndex(_currentSceneId.length));					_eventType = SceneEvent.LOAD;					break;				case SceneEvent.INIT : _eventType = SceneEvent.GOTO; break;				case SceneEvent.GOTO :					_current = _current.scenes["getChild"](_destinedSceneId.getNameByIndex(_currentSceneId.length));					_eventType = SceneEvent.LOAD;					break;				case SceneEvent.ASCEND : _eventType = SceneEvent.DESCEND; break;				case SceneEvent.UNLOAD : _eventType = SceneEvent.LOAD; break;			}						_executeProgress();			return;		}				// 目的のシーンが親または親戚		switch (_eventType)		{			case SceneEvent.LOAD : _eventType = SceneEvent.UNLOAD; break;			case SceneEvent.DESCEND : _eventType = SceneEvent.ASCEND; break;			case SceneEvent.INIT : _eventType = SceneEvent.GOTO; break;			case SceneEvent.GOTO : _eventType = SceneEvent.UNLOAD; break;			case SceneEvent.ASCEND : _eventType = SceneEvent.UNLOAD; break;			case SceneEvent.UNLOAD :				if (_currentSceneId.length > 2 && String(_currentSceneId.transfer("../")) == String(_destinedSceneId.transfer("../")))				{					_current = _rootScene;					var l:Number = _destinedSceneId.length;					for (var i:Number = 1; i < l; i++) _current = _current.scenes["getChild"](_destinedSceneId.getNameByIndex(i));					_eventType = SceneEvent.LOAD;					break;				}								_current = current.parent;								// 目的のシーンと現在のシーンが同一であれば				if (String(_current.sceneId) == String(_destinedSceneId))				{					_eventType = SceneEvent.INIT;					break;				}								// 目的のシーンが現在のシーンの親シーンであれば				_eventType = SceneEvent.ASCEND;				break;		}		_executeProgress();	}		private function _executeProgress():Void	{		// シーンが存在しているかどうか確認する
		if (current instanceof SceneObject) {			_currentSceneId = _current.sceneId.clone();		} else {			// シーンが存在しなければ、エラーを送出して終了する			dispatchEvent(new ProcessEvent(ProcessEvent.PROCESS_ERROR, current, eventType));			return;		}				// シーンのコマンドリストを消去する		_current.clearCommand();				// シーンが変更されていればイベントを送出する		if (String(_currentSceneId) != String(_previousSceneId))		{			dispatchEvent(new ProcessEvent(ProcessEvent.PROCESS_SCENE, current, eventType));		}				// イベントを送出する		dispatchEvent(new ProcessEvent(ProcessEvent.PROCESS_EVENT, current, eventType));		_current.dispatchEvent(new SceneEvent(eventType, current, eventType));		
		// コマンドを取得する
		_command = CommandList(_current["getCommands"]());				if (_command && _command.length > 0)		{			_command.addExclusivelyEventListener(CommandEvent.COMMAND_START, _commandStartDelegate);			_command.addExclusivelyEventListener(CommandEvent.COMMAND_COMPLETE, _commandCompleteDelegate);			_command.addExclusivelyEventListener(CommandCatchEvent.EXCEPTION, _catchDelegate);			_command.addExclusivelyEventListener(CommandCatchEvent.EVENT, _catchDelegate);			_command.execute(new Object());			return;		}
				_executeComplete();	}		private function _executeComplete():Void	{		// 目的のシーンに到達していなければ		if (String(_currentSceneId) != String(_destinedSceneId))		{			_executeStart();			return;		}				// イベントタイプ SceneEvent.INIT でなければ		if (_eventType != SceneEvent.INIT)		{			_executeStart();			return;		}				_running = false;				if (autoLock) lock = false;				dispatchEvent(new ProcessEvent(ProcessEvent.PROCESS_COMPLETE, current, eventType));	}		public function interrupt():Void	{		// 実行中でなければ終了する		if (!running) return;				// すでに処理していれば終了する		if (interrupting) return;				_interrupting = true;				// 実行中のコマンドがあれば		if (_command) {			// リスナーを解除する			_command.removeAllListeners(true);						// リスナーを登録する			_command.addExclusivelyEventListener(CommandEvent.COMMAND_INTERRUPT, _commandInterruptDelegate);						// 停止処理を実行する			_command.interrupt();			return;		}				// 処理を終了する		_running = false;				// イベントを送出する		dispatchEvent(new ProcessEvent(ProcessEvent.PROCESS_INTERRUPT, current, eventType));	}		public function toString():String	{		return "[object SceneManager]";	}				private function _commandStartHandler(e:CommandEvent):Void	{		Command(e.target).removeEventListener(CommandEvent.COMMAND_START, _commandStartDelegate);	}		private function _commandCompleteHandler(e:CommandEvent):Void	{		Command(e.target).removeAllListeners(true);				_executeComplete();	}		private function _commandInterruptHandler(e:CommandEvent):Void	{		Command(e.target).removeAllListeners(true);				_running = false;				dispatchEvent(new ProcessEvent(ProcessEvent.PROCESS_INTERRUPT, current, eventType));	}		private function _catchHandler(e:CommandCatchEvent):Void	{		Command(e.target).removeAllListeners(true);				_executeComplete();	}		private function _processInterruptHandler(e:ProcessEvent):Void	{		removeEventListener(ProcessEvent.PROCESS_INTERRUPT, _processInterruptDelegate);				// 中断処理を停止する		_interrupting = false;				// 移動する		goto(destinedSceneId);	}}