import jp.progression.Progression;import jp.progression.commands.ParallelList;import jp.progression.commands.SerialList;import jp.progression.core.collections.SceneCollection;import jp.progression.core.collections.SceneList;import jp.progression.core.commands.Command;import jp.progression.core.commands.CommandExecutor;import jp.progression.core.commands.CommandList;import jp.progression.core.commands.ICommandExecutable;import jp.progression.events.EventIntegrator;import jp.progression.events.ProcessEvent;import jp.progression.events.SceneEvent;import jp.progression.scenes.SceneId;import jp.progression.utils.ObjectUtil;import mx.events.EventDispatcher;/** *  * Progression for ActionScript 2.0 *  * @author	Copyright (c) 2007 Mk-10:cellfusion.jp, supported by Spark project. * @version	1.0.0 Alpha *  * @see		http://progression.jp/ * @see		http://usage.progression.jp/ * @see		http://progression.libspark.org/ *  * @see		http://cellfusion.jp/ * @see		http://www.libspark.org/ *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or implied. See the License for the specific language * governing permissions and limitations under the License. *  */class jp.progression.scenes.SceneObject extends EventIntegrator implements ICommandExecutable{	private static var _owner:Progression;	private var _className:String;	private var _name:String;	private var _uniqueName:String;	private var _id:String;	private var _group:String;	private var _scenes:Array = [];	private var _progression:Progression;	private var _root:SceneObject;	private var _parent:SceneObject;	private var _next:SceneObject;	private var _previous:SceneObject;	private var _isCurrent:Boolean;	private var _isParent:Boolean;	private var _isChild:Boolean;	private var _isVisited:Boolean;	private var _title:String;	private var _executor:CommandExecutor;	private var _sceneInfo:SceneInfo;	private var _eventHandlerEnabled = true;	private var __onLoad:Function;	private var __onUnLoad:Function;	private var __onInit:Function;	private var __onGoto:Function;	private var __onDescend:Function;	private var __onAscend:Function;	private var __onSceneAdded:Function;	private var __onSceneAddedToRoot:Function;	private var __onSceneRemoved:Function;	private var __onSceneRemovedFromRoot:Function;	private var __onSceneTitle:Function;	private var __onSceneStateChange:Function;	/**	 * シーンオブジェクトを作成	 */	public function SceneObject(name:String, initObject:Object)	{		name = name || null;		initObject = initObject || null;				// クラス名を取得する		_className = "dummy";				// SceneCollection に登録する		SceneCollection["addInstance"](this);				// ユニーク名を設定する		_uniqueName = "scene_" + SceneCollection["getNumByInstance"](this);				// 引数を設定する		this.name = name;				// 初期化する		eventHandlerEnabled = true;				// SceneInfo を設定する		_sceneInfo = SceneInfo["createInstance"](this);				// CommandExecutor を作成する		_executor = CommandExecutor["createInstance"](this);				// 初期化する		setProgression(initObject);				// リスナーを登録する		addExclusivelyEventListener(SceneEvent.INIT, _init);				// _owner が存在すれば		if (_owner) {			this.name = _owner.id;			_progression = _owner;			_root = this;			_owner = null;		}	}	public function getScenesById(id:String):SceneObject	{		return SceneCollection["getInstanceById"](id);	}	public function getScenesBySceneid(sceneId:SceneId):SceneObject	{		return SceneCollection["getInstanceBySceneId"](sceneId);	}	public function getScenesByGroup(group:String, sort:Boolean):Array	{		sort = sort || false;		return SceneCollection["getInstanceByGroup"](group, sort);	}	public function addCommand():Void	{		var commands:Array = [];		for (var i:Number = 0;i < arguments.length; i++) {			commands.push(arguments[i]);		}				_executor["addCommand"].apply(null, commands);	}	public function insertCommand():Void	{		var commands:Array = [];		for (var i:Number = 0;i < arguments.length; i++) {			commands.push(arguments[i]);		}				_executor["insertCommand"].apply(null, commands);	}	public function clearCommand(completely:Boolean):Void	{		completely = completely || false;		_executor["clearCommand"](completely);	}	public function setProperties(props:Object):SceneObject	{		ObjectUtil.setProperties(this, props);		return this;	}	/**	 * シーンオブジェクトを追加	 */	public function addScene(scene:SceneObject):SceneObject	{		return _registerScene(scene, _scenes.length);	}	public function addSceneAt(scene:SceneObject, index:Number):SceneObject	{		if (index < 0 || _scenes.length < index) {			// エラー		}		return _registerScene(scene, index);	}	public function addSceneAtAbove(scene:SceneObject, index:Number):SceneObject	{		if (index < 0 || _scenes.length < index) {			// エラー		}		return _registerScene(scene, index + 1);	}	public function addSceneFromXML(xml:XML):Void	{		// めんどいので後で	}	public function removeScene(scene:SceneObject):SceneObject	{		return _unregisterScene(scene);	}	public function removeSceneAt(index:Number):SceneObject	{		return _unregisterScene(getSceneAt(index));	}	public function removeAllScene():Void	{		while (_scenes.length > 0) {			removeScene(_scenes[0]);		}	}
	public function contains(scene:SceneObject):Boolean
	{
		// 自分自身であれば true を返す		if (scene == this) return true;				// 子または孫に存在すれば true を返す		for (var i:Number = 0;i < _scenes.length; i++) {			var target:SceneObject = SceneObject(_scenes[i]);						if (target == scene) return true;			if (target.contains(scene)) return true;		}				return false;
	}
	public function getSceneAt(index:Number):SceneObject
	{
		return _scenes[index] instanceof SceneObject ? _scenes[index] : null;
	}
	public function getSceneByName(name:String):SceneObject
	{
		for (var i:Number = 0;i < _scenes.length; i++) {			var child:SceneObject = SceneObject(_scenes[i]);			if (child.name == name) return child;		}				return null;
	}
	public function getSceneIndex(scene:SceneObject):Number
	{
		for (var i:Number = 0;i < _scenes.length; i++) {			if (_scenes[i] == scene) return i;		}				return -1;
	}	public function setSceneIndex(scene:SceneObject, index:Number):Void	{		addSceneAt(removeScene(scene), index);	}	public function setSceneIndexAtAbove(scene:SceneObject, index:Number):Void	{		addSceneAtAbove(removeScene(scene), index);
	}	public function swapScenes(scene1:SceneObject, scene2:SceneObject):Void	{		// インデックス位置を取得する		var index1:Number = getSceneIndex(scene1);		var index2:Number = getSceneIndex(scene2);				// インデックスの数値によって入れ替える		if (index1 < index2) {			var tmpScene:SceneObject = scene1;			var tmpIndex:Number = index1;			scene1 = scene2;			scene2 = tmpScene;			index1 = index2;			index2 = tmpIndex;		}				// シーンリストから削除する		removeScene(scene1);		removeScene(scene2);				// シーンリストに追加する		addSceneAt(scene1, index2);		addSceneAt(scene2, index1);	}	public function swapScenesAt(index1:Number, index2:Number):Void	{		// シーンオブジェクトを取得する		var scene1:SceneObject = getSceneAt(index1);		var scene2:SceneObject = getSceneAt(index2);				// インデックスの数値によって入れ替える		if (index1 < index2) {			var tmpScene:SceneObject = scene1;			var tmpIndex:Number = index1;			scene1 = scene2;			scene2 = tmpScene;			index1 = index2;			index2 = tmpIndex;		}				// シーンリストから削除する		removeScene(scene1);		removeScene(scene2);				// シーンリストに追加する		addSceneAt(scene1, index2);		addSceneAt(scene2, index1);	}	public function toXMLString():String	{		return "dummy";	}	public function toString():String	{		return '[SceneObject sceneId="' + sceneId + '" id="' + _id + '" name="' + _name + '" group="' + _group + '"]';	}	// private 	private function _registerScene(scene:SceneObject, index:Number):SceneObject	{		// ルートであればエラーを送出する		if (scene.root == scene) {			// えらー		}				// すでに同名のシーンオブジェクトが存在していればエラーを送出する		if (getSceneByName(scene.name)) {			// えらー		}				// すでに親が存在していれば解除する		if (scene.parent) {			scene.parent._unregisterScene(scene);		}				// 登録する		_scenes.splice(index, 0, scene);				// 現在のルートシーンを取得する		var previousRoot:SceneObject = scene._root;				// 前後を取得する		var next:SceneObject = _scenes[index + 1];		var previous:SceneObject = _scenes[index - 1];				// 関係を設定する設定する		scene["setProgression"](progression);		scene["setRoot"](root);		scene._parent = this;		scene._next = next;		scene._previous = previous;				if (next) next._previous = scene;		if (previous) previous._next = next;				// イベントリスナーを登録する		scene.addExclusivelyEventListener(SceneEvent.SCENE_ADDED, dispatchEvent);		scene.addExclusivelyEventListener(SceneEvent.SCENE_REMOVED, dispatchEvent);		addExclusivelyEventListener(SceneEvent.SCENE_ADDED_TO_ROOT, scene.dispatchEvent);		addExclusivelyEventListener(SceneEvent.SCENE_REMOVED_FROM_ROOT, scene.dispatchEvent);				// イベントを送出する		scene.dispatchEvent(new SceneEvent(SceneEvent.SCENE_ADDED));				// ルートシーンが存在し、変更されていれば		if (root && previousRoot != root) {			// イベントを送出する			scene.dispatchEvent(new SceneEvent(SceneEvent.SCENE_ADDED_TO_ROOT));		}				return scene;	}	private function _unregisterScene(scene:SceneObject):SceneObject	{		for (var i:Number = 0;i < _scenes.length; i++) {			var child:SceneObject = SceneObject(_scenes[i]);						// 違っていれば次へ			if (child != scene) continue;						// 前後を取得する			var next:SceneObject = _scenes[i + i];			var previous:SceneObject = _scenes[i - 1];						// 現在のルートシーンを取得する			var previousRoot:SceneObject = scene._root;						// 関係を設定する			scene["setProgression"](null);			scene["setRoot"](null);			scene._parent = null;			scene._next = null;			scene._previous = null;			scene._isChild = false;			scene._isCurrent = false;			scene._isParent = false;			scene._isVisited = false;						// 前後関係を設定する			if (next) next._previous = previous;			if (previous) previous._next = next;						// 登録を解除する			_scenes.splice(i, 1);						// イベントを送出する			scene.dispatchEvent(new SceneEvent(SceneEvent.SCENE_REMOVED));						// ルートシーンが存在せず、変更されていれば			if (!scene._root && previousRoot != scene._root) {				scene.dispatchEvent(new SceneEvent(SceneEvent.SCENE_REMOVED_FROM_ROOT));			}						// イベントリスナーを解除する			scene.completelyRemoveEventListener(SceneEvent.SCENE_ADDED, dispathEvent);			scene.completelyRemoveEventListener(SceneEvent.SCENE_REMOVED, dispathEvent);			completelyRemoveEventListener(SceneEvent.SCENE_ADDED_TO_ROOT, scene.dispatchEvent);			completelyRemoveEventListener(SceneEvent.SCENE_REMOVED_FROM_ROOT, scene.dispatchEvent);		}				return scene;	}	private function _onLoad():Void 	{	};	private function _onInit():Void 	{	};	private function _onGoto():Void 	{	};	private function _onUnLoad():Void 	{	};	private function _onDescend():Void 	{	};	private function _onAscend():Void 	{	};	private function _onSceneAdded():Void 	{	};		private function _onSceneAddedToRoot():Void 	{	};	private function _onSceneRemoved():Void 	{	};		private function _onSceneRemovedFromRoot():Void 	{	};		private function _onSceneTitle():Void 	{	};		private function _onSceneStateChange():Void 	{	};	// event	private function _load(e:SceneEvent):Void	{		onLoad.apply(this, []);	}	private function _unload(e:SceneEvent):Void	{		onUnLoad.apply(this, []);	}	private function _init(e:SceneEvent):Void	{		// 未読であれば		if (!_isVisited) {			// 既読にする			_isVisited = true;						dispatchEvent(new SceneEvent(SceneEvent.SCENE_STATE_CHANGE));		}				if (_eventHandlerEnabled) {			onInit.apply(this, []);		}	}	private function _goto(e:SceneEvent):Void	{		onGoto.apply(this, []);	}	private function _descend(e:SceneEvent):Void	{		onDescend.apply(this, []);	}	private function _ascend(e:SceneEvent):Void	{		onAscend.apply(this, []);	}	private function _sceneAdded(e:SceneEvent):Void	{		onSceneAdded.apply(this, []);	}	private function _sceneAddedToRoot(e:SceneEvent):Void	{		onSceneAddedToRoot.apply(this, []);	}	private function _sceneRemoved(e:SceneEvent):Void	{		onSceneRemoved.apply(this, []);	}	private function _sceneRemovedFromRoot(e:SceneEvent):Void	{		onSceneRemovedFromRoot.apply(this, []);	}	private function _sceneTitle(e:SceneEvent):Void	{		onSceneTitle.apply(this, []);	}	private function _sceneStateChange(e:SceneEvent):Void	{		onSceneStateChange.apply(this, []);	}	private function _processScene(e:ProcessEvent):Void	{		// 現在の設定を保存する		var isCurrent:Boolean = _isCurrent;		var isParent:Boolean = _isParent;		var isChild:Boolean = _isChild;				// カレントシーンに該当するかどうか		_isCurrent = (this == e.scene);				// 親シーンに該当するか		_isParent = !(_isCurrent || e.scene.sceneId.contains(sceneId));				// 子シーンに該当するかどうか		_isChild = (!_isCurrent && e.scene.sceneId.contains(sceneId));				// 変化していなければ終了する		if (isCurrent == _isCurrent && isParent == _isParent && isChild == _isChild) {			return;		}				// イベントを送出する		dispatchEvent(new SceneEvent(SceneEvent.SCENE_STATE_CHANGE, this));	}	// getter/setter	public function get className():String	{		return _className;	}	public function get name():String 	{ 		return _name; 	}	public function set name(value:String):Void	{		value = value || _uniqueName;				switch (true) {			case _root == this : 				// エラー			case !_parent && !_parent.getSceneByName(value) : 				// エラー			case value == _uniqueName : 				break;			case !SceneId.validate("/" + value) : 				// エラー		}				_name = value;	}	public function get sceneId():SceneId	{		// ルートが存在しなければ null を返す		if (!_root) return null;				// ルートが自分であれば		if (_root == this) return new SceneId("/" + name);				return new SceneId(_parent.sceneId.path + "/" + name);	}	public function get progression():Progression 	{ 		return getProgression(); 	}	public function get root():SceneObject 	{ 		return _root; 	}	public function get parent():SceneObject 	{ 		return _parent; 	}	public function get next():SceneObject	{		return _next;	}	public function get previous():SceneObject	{		return _previous;	}	public function get scenes():Array	{ 		return _scenes.slice(); 	}	public function get numScenes():Number	{		return scenes.length;		}	public function get isCurrent():Boolean 	{ 		return _isCurrent; 	}	public function get isParent():Boolean 	{ 		return _isParent; 	}	public function get isChild():Boolean 	{ 		return _isChild; 	}	public function get isVisited():Boolean	{		return _isVisited;	}	public function get title():String	{		return _title || (parent ? parent.title + " | " : "") + _name;	}	public function set title(value:String):Void	{		_title = value;		dispatchEvent(new SceneEvent(SceneEvent.SCENE_TITLE));	}	public function get parallelMode():Boolean 	{ 		return _executor["getParrallelMode"](); 	}	public function set parallelMode(value:Boolean):Void	{		_executor["setParallelMode"](value);	}	public function get executor():CommandExecutor	{		return _executor;	}	public function get eventHandlerEnabled():Boolean	{		return _eventHandlerEnabled;	}	public function set enavenhandlerEnabled(value:Boolean):Void	{		if (_eventHandlerEnabled = value) {			addExclusivelyEventListener(SceneEvent.LOAD, _load);			addExclusivelyEventListener(SceneEvent.UNLOAD, _unload);			addExclusivelyEventListener(SceneEvent.GOTO, _goto);			addExclusivelyEventListener(SceneEvent.DESCEND, _descend);			addExclusivelyEventListener(SceneEvent.ASCEND, _ascend);			addExclusivelyEventListener(SceneEvent.SCENE_ADDED, _sceneAdded);			addExclusivelyEventListener(SceneEvent.SCENE_ADDED_TO_ROOT, _sceneAddedToRoot);			addExclusivelyEventListener(SceneEvent.SCENE_REMOVED, _sceneRemoved);			addExclusivelyEventListener(SceneEvent.SCENE_REMOVED_FROM_ROOT, _sceneRemovedFromRoot);			addExclusivelyEventListener(SceneEvent.SCENE_TITLE, _sceneTitle);			addExclusivelyEventListener(SceneEvent.SCENE_STATE_CHANGE, _sceneStateChange);		} else {			completelyEventListener(SceneEvent.LOAD, _load);			completelyEventListener(SceneEvent.UNLOAD, _unload);			completelyEventListener(SceneEvent.GOTO, _goto);			completelyEventListener(SceneEvent.DESCEND, _descend);			completelyEventListener(SceneEvent.ASCEND, _ascend);			completelyEventListener(SceneEvent.SCENE_ADDED, _sceneAdded);			completelyEventListener(SceneEvent.SCENE_ADDED_TO_ROOT, _sceneAddedToRoot);			completelyEventListener(SceneEvent.SCENE_REMOVED, _sceneRemoved);			completelyEventListener(SceneEvent.SCENE_REMOVED_FROM_ROOT, _sceneRemovedFromRoot);			completelyEventListener(SceneEvent.SCENE_TITLE, _sceneTitle);			completelyEventListener(SceneEvent.SCENE_STATE_CHANGE, _sceneStateChange);		}	}	public function get onLoad():Function 	{ 		return __onLoad || _onLoad; 	}	public function set onLoad(value:Function):Void 	{ 		__onLoad = value; 	}	public function get onUnLoad():Function 	{ 		return __onUnLoad || _onUnLoad; 	}	public function set onUnLoad(value:Function):Void 	{ 		__onUnLoad = value; 	}	public function get onInit():Function 	{ 		return __onInit || _onInit; 	}	public function set onInit(value:Function):Void 	{ 		__onInit = value; 	}	public function get onGoto():Function 	{ 		return __onGoto || _onGoto; 	}	public function set onGoto(value:Function):Void 	{ 		__onGoto = value; 	}	public function get onDescend():Function 	{ 		return __onDescend || _onDescend; 	}	public function set onDescend(value:Function):Void 	{ 		__onDescend = value; 	}	public function get onAscend():Function 	{ 		return __onAscend || _onAscend; 	}	public function set onAscend(value:Function):Void 	{ 		__onAscend = value; 	}	public function get onSceneAdded():Function 	{ 		return __onSceneAdded || _onSceneAdded; 	}	public function set onSceneAdded(value:Function):Void 	{ 		__onSceneAdded = value; 	}		public function get onSceneAddedToRoot():Function 	{ 		return __onSceneAddedToRoot || _onSceneAddedToRoot; 	}	public function set onSceneAddedToRoot(value:Function):Void 	{ 		__onSceneAddedToRoot = value; 	}	public function get onSceneRemoved():Function 	{ 		return __onSceneRemoved || _onSceneRemoved; 	}	public function set onSceneRemoved(value:Function):Void 	{ 		__onSceneRemoved = value; 	}		public function get onSceneRemovedFromRoot():Function 	{ 		return __onSceneRemovedFromRoot || _onSceneRemovedFromRoot; 	}	public function set onSceneRemovedFromRoot(value:Function):Void 	{ 		__onSceneRemovedFromRoot = value; 	}		public function get onSceneTitle():Function 	{ 		return __onSceneTitle || _onSceneTitle; 	}	public function set onSceneTitle(value:Function):Void 	{ 		__onSceneTitle = value; 	}	public function get onSceneStateChange():Function 	{ 		return __onSceneStateChange || _onSceneStateChange; 	}	public function set onSceneStateChange(value:Function):Void 	{ 		__onSceneStateChange = value; 	}	// 隠蔽したい getter/setter	public function getOwner():Progression	{		return _owner;	}	public function setOwner(value:Progression):Void	{		_owner = value;	}	private function getProgression():Progression 	{ 		return _progression; 	}	private function setProgression(value:Progression):Void	{		// 設定が存在していれば		if (_progression) {			// リスナーを解除する			_progression.completelyRemoveEventListener(ProcessEvent.PROCESS_SCENE, _processScene);		}				// 値を設定する		_progression = value;				if (_progression) {			// リスナーを登録する			_progression.addExclusivelyEventListener(ProcessEvent.PROCESS_SCENE, _processScene);		}				// 子の関連性を再設定する		for (var i:Number = 0;i < _scenes.length; i++) {			SceneObject(_scenes[i])["setProgression"](value);		}	}	private function getRoot():SceneObject 	{ 		return _root;	}	private function setRoot(value:SceneObject):Void	{		_root = value;				// 子の関連性を再設定する		for (var i:Number = 0;i < _scenes.length; i++) {			SceneObject(_scenes[i])["setRoot"](value);		}	}}