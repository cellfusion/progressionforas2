import mx.events.EventDispatcher;import mx.utils.Delegate;import jp.progression.events.Event;import jp.progression.events.EventIntegrator;/** *  * Progression for ActionScript 2.0 *  * @author	Copyright (c) 2007 Mk-10:cellfusion.jp, supported by Spark project. * @version	1.0.0 Alpha *  * @see		http://progression.jp/ * @see		http://usage.progression.jp/ * @see		http://progression.libspark.org/ *  * @see		http://cellfusion.jp/ * @see		http://www.libspark.org/ *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or implied. See the License for the specific language * governing permissions and limitations under the License. *  */class jp.progression.events.EventUnit extends EventIntegrator {		private var _events:Object;	private var _eventUnitDelegate:Function;		public function EventUnit()	{		// 初期化する		_events = {};				_eventUnitDelegate = Delegate.create(this, _eventUnitHandler);	}		public function addEventUnit(target:Object, type:String):Void	{		if (!_events[target]) _events[target] = {};		_events[target][type] = {completed:false};				if (target.addEventListener) {			target.addEventListener(type, _eventUnitDelegate);		} else if (target.addListener) {			var scope = this;			target.addListener(_events[target][type]);			_events[target][type][type] = function():Void{				var e:Event = new Event(type);				e["_target"] = target;				scope._eventUnitHandler(e);			};		}	}		public function removeEventUnit(target:Object, type:String):Void	{		if (target.addEventListener) {			target.removeEventListener(type, _eventUnitDelegate);		} else if (target.addListener) {			target.removeListener(_events[target][type]);		}				delete _events[target][type];	}		public function reset():Void	{		for (var target:String in _events) {			for (var type:String in _events[target]) {				_events[target][type].completed = false;			}		}	}		private function _eventUnitHandler(e:Event):Void	{		_events[e.target][e.type].completed = true;				for (var target:String in _events) {			for (var type:String in _events[target]) {				if (!_events[target][type].completed) return;			}		}				dispatchEvent(new Event(Event.COMPLETE, this));	}}